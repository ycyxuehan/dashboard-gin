// Copyright 2017 The Kubernetes Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package client

import (
	"log"
	"strings"

	v1 "k8s.io/api/authorization/v1"
	apiextensionsclientset "k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/tools/clientcmd/api"

	"github.com/gin-gonic/gin"
	pluginclientset "github.com/ycyxuehan/dashboard-gin/backend/plugin/client/clientset/versioned"
	"github.com/ycyxuehan/dashboard-gin/backend/resource/customresourcedefinition"

	"github.com/ycyxuehan/dashboard-gin/backend/args"
	authApi "github.com/ycyxuehan/dashboard-gin/backend/auth/api"
	clientapi "github.com/ycyxuehan/dashboard-gin/backend/client/api"
	"github.com/ycyxuehan/dashboard-gin/backend/client/csrf"
	"github.com/ycyxuehan/dashboard-gin/backend/errors"
)

// Dashboard UI default values for client configs.
const (
	// High enough QPS to fit all expected use cases. QPS=0 is not set here, because
	// client code is overriding it.
	DefaultQPS = 1e6
	// High enough Burst to fit all expected use cases. Burst=0 is not set here, because
	// client code is overriding it.
	DefaultBurst = 1e6
	// Use kubernetes protobuf as content type by default
	DefaultContentType = "application/vnd.kubernetes.protobuf"
	// Default cluster/context/auth name to be set in clientcmd config
	DefaultCmdConfigName = "kubernetes"
	// Header name that contains token used for authorization. See TokenManager for more information.
	JWETokenHeader = "jweToken"
	// Default http header for user-agent
	DefaultUserAgent = "dashboard"
	//Impersonation Extra header
	ImpersonateUserExtraHeader = "Impersonate-Extra-"
)

// VERSION of this binary
var Version = "UNKNOWN"

// clientManager implements ClientManager interface
type clientManager struct {
	// Autogenerated key on backend start used to secure requests from csrf attacks
	csrfKey string
	// Path to kubeconfig file. If both kubeConfigPath and apiserverHost are empty
	// inClusterConfig will be used
	kubeConfigPath string
	// Address of apiserver host in format 'protocol://address:port'
	apiserverHost string
	// Initialized on clientManager creation and used if kubeconfigPath and apiserverHost are
	// empty
	inClusterConfig *rest.Config
	// Responsible for decrypting tokens coming in request header. Used for authentication.
	tokenManager authApi.TokenManager
	// API Extensions client created without providing auth info. It uses permissions granted to
	// service account used by dashboard or kubeconfig file if it was passed during dashboard init.
	insecureAPIExtensionsClient apiextensionsclientset.Interface
	// Plugin client created without providing auth info. It uses permissions granted to
	// service account used by dashboard or kubeconfig file if it was passed during dashboard init.
	insecurePluginClient pluginclientset.Interface
	// Kubernetes client created without providing auth info. It uses permissions granted to
	// service account used by dashboard or kubeconfig file if it was passed during dashboard init.
	insecureClient kubernetes.Interface
	// Kubernetes client config created without providing auth info. It uses permissions granted
	// to service account used by dashboard or kubeconfig file if it was passed during dashboard
	// init.
	insecureConfig *rest.Config
}

// Client returns a kubernetes client. In case dashboard login is enabled and option to skip
// login page is disabled only secure client will be returned, otherwise insecure client will be
// used.c
func (cm *clientManager) Client(c *gin.Context) (kubernetes.Interface, error) {
	if c == nil {
		return nil, errors.NewBadRequest("request can not be nil")
	}
	if cm.isSecureModeEnabled(c) {
		return cm.secureClient(c)
	}

	return cm.InsecureClient(), nil
}

// APIExtensionsClient returns an API Extensions client. In case dashboard login is enabled and
// option to skip login page is disabled only secure client will be returned, otherwise insecure
// client will be used.
func (cm *clientManager) APIExtensionsClient(c *gin.Context) (apiextensionsclientset.Interface, error) {
	if c == nil {
		return nil, errors.NewBadRequest("request can not be nil!")
	}

	if cm.isSecureModeEnabled(c) {
		return cm.secureAPIExtensionsClient(c)
	}

	return cm.InsecureAPIExtensionsClient(), nil
}

// PluginClient returns a plugin client. In case dashboard login is enabled and
// option to skip login page is disabled only secure client will be returned, otherwise insecure
// client will be used.
func (cm *clientManager) PluginClient(c *gin.Context) (pluginclientset.Interface, error) {
	if c == nil {
		return nil, errors.NewBadRequest("request can not be nil!")
	}

	if cm.isSecureModeEnabled(c) {
		return cm.securePluginClient(c)
	}

	return cm.InsecurePluginClient(), nil
}

// Config returns a rest config. In case dashboard login is enabled and option to skip
// login page is disabled only secure config will be returned, otherwise insecure config will be
// used.
func (cm *clientManager) Config(c *gin.Context) (*rest.Config, error) {
	if c == nil {
		return nil, errors.NewBadRequest("request can not be nil")
	}

	if cm.isSecureModeEnabled(c) {
		return cm.secureConfig(c)
	}

	return cm.InsecureConfig(), nil
}

// InsecureClient returns kubernetes client that was created without providing auth info. It uses
// permissions granted to service account used by dashboard or kubeconfig file if it was passed
// during dashboard init.
func (cm *clientManager) InsecureClient() kubernetes.Interface {
	return cm.insecureClient
}

// InsecureAPIExtensionsClient returns API Extensions client that was created without providing
// auth info. It uses permissions granted to service account used by dashboard or kubeconfig file
// if it was passed during dashboard init.
func (cm *clientManager) InsecureAPIExtensionsClient() apiextensionsclientset.Interface {
	return cm.insecureAPIExtensionsClient
}

// InsecurePluginClient returns plugin client that was created without providing
// auth info. It uses permissions granted to service account used by dashboard or kubeconfig file
// if it was passed during dashboard init.
func (cm *clientManager) InsecurePluginClient() pluginclientset.Interface {
	return cm.insecurePluginClient
}

// InsecureConfig returns kubernetes client config that used privileges of dashboard service account
// or kubeconfig file if it was passed during dashboard init.
func (cm *clientManager) InsecureConfig() *rest.Config {
	return cm.insecureConfig
}

// CanI returns true when user is allowed to access data provided within SelfSubjectAccessReview, false otherwise.
func (cm *clientManager) CanI(c *gin.Context, ssar *v1.SelfSubjectAccessReview) bool {
	// In case user is not authenticated (uses skip option) do not allow access.
	info, _ := cm.extractAuthInfo(c)
	if info == nil && len(args.Holder.GetCertFile()) > 0 && len(args.Holder.GetKeyFile()) > 0 {
		return false
	}

	client, err := cm.Client(c)
	if err != nil {
		log.Println(err)
		return false
	}

	response, err := client.AuthorizationV1().SelfSubjectAccessReviews().Create(ssar)
	if err != nil {
		log.Println(err)
		return false
	}

	return response.Status.Allowed
}

// ClientCmdConfig creates ClientCmd Config based on authentication information extracted from request.
// Currently request header is only checked for existence of 'Authentication: BearerToken'
func (cm *clientManager) ClientCmdConfig(c *gin.Context) (clientcmd.ClientConfig, error) {
	authInfo, err := cm.extractAuthInfo(c)
	if err != nil {
		return nil, err
	}

	cfg, err := cm.buildConfigFromFlags(cm.apiserverHost, cm.kubeConfigPath)
	if err != nil {
		return nil, err
	}

	return cm.buildCmdConfig(authInfo, cfg), nil
}

// CSRFKey returns key that is generated upon client manager creation
func (cm *clientManager) CSRFKey() string {
	return cm.csrfKey
}

// HasAccess configures K8S api client with provided auth info and executes a basic check against apiserver to see
// if it is valid.
func (cm *clientManager) HasAccess(authInfo api.AuthInfo) error {
	cfg, err := cm.buildConfigFromFlags(cm.apiserverHost, cm.kubeConfigPath)
	if err != nil {
		return err
	}

	clientConfig := cm.buildCmdConfig(&authInfo, cfg)
	cfg, err = clientConfig.ClientConfig()
	if err != nil {
		return err
	}

	client, err := kubernetes.NewForConfig(cfg)
	if err != nil {
		return err
	}

	_, err = client.ServerVersion()
	return err
}

// VerberClient returns new verber client based on authentication information extracted from request
func (cm *clientManager) VerberClient(c *gin.Context, config *rest.Config) (clientapi.ResourceVerber, error) {
	k8sClient, err := cm.Client(c)
	if err != nil {
		return nil, err
	}

	apiextensionsclient, err := cm.APIExtensionsClient(c)
	if err != nil {
		return nil, err
	}

	pluginsclient, err := cm.PluginClient(c)
	if err != nil {
		return nil, err
	}

	apiextensionsRestClient, err := customresourcedefinition.GetExtensionsAPIRestClient(apiextensionsclient)
	if err != nil {
		return nil, err
	}

	return NewResourceVerber(
		k8sClient.CoreV1().RESTClient(),
		k8sClient.ExtensionsV1beta1().RESTClient(),
		k8sClient.AppsV1().RESTClient(),
		k8sClient.BatchV1().RESTClient(),
		k8sClient.BatchV1beta1().RESTClient(),
		k8sClient.AutoscalingV1().RESTClient(),
		k8sClient.StorageV1().RESTClient(),
		k8sClient.RbacV1().RESTClient(),
		k8sClient.NetworkingV1().RESTClient(),
		apiextensionsRestClient,
		pluginsclient.DashboardV1alpha1().RESTClient(),
		config), nil
}

// SetTokenManager sets the token manager that will be used for token decryption.
func (cm *clientManager) SetTokenManager(manager authApi.TokenManager) {
	cm.tokenManager = manager
}

// Initializes config with default values
func (cm *clientManager) initConfig(cfg *rest.Config) {
	cfg.QPS = DefaultQPS
	cfg.Burst = DefaultBurst
	cfg.ContentType = DefaultContentType
	cfg.UserAgent = DefaultUserAgent + "/" + Version
}

// Returns rest Config based on provided apiserverHost and kubeConfigPath flags. If both are
// empty then in-cluster config will be used and if it is nil the error is returned.
func (cm *clientManager) buildConfigFromFlags(apiserverHost, kubeConfigPath string) (
	*rest.Config, error) {
	if len(kubeConfigPath) > 0 || len(apiserverHost) > 0 {
		return clientcmd.NewNonInteractiveDeferredLoadingClientConfig(
			&clientcmd.ClientConfigLoadingRules{ExplicitPath: kubeConfigPath},
			&clientcmd.ConfigOverrides{ClusterInfo: api.Cluster{Server: apiserverHost}}).ClientConfig()
	}

	if cm.isRunningInCluster() {
		return cm.inClusterConfig, nil
	}

	return nil, errors.NewInvalid("could not create client config")
}

// Based on auth info and rest config creates client cmd config.
func (cm *clientManager) buildCmdConfig(authInfo *api.AuthInfo, cfg *rest.Config) clientcmd.ClientConfig {
	cmdCfg := api.NewConfig()
	cmdCfg.Clusters[DefaultCmdConfigName] = &api.Cluster{
		Server:                   cfg.Host,
		CertificateAuthority:     cfg.TLSClientConfig.CAFile,
		CertificateAuthorityData: cfg.TLSClientConfig.CAData,
		InsecureSkipTLSVerify:    cfg.TLSClientConfig.Insecure,
	}
	cmdCfg.AuthInfos[DefaultCmdConfigName] = authInfo
	cmdCfg.Contexts[DefaultCmdConfigName] = &api.Context{
		Cluster:  DefaultCmdConfigName,
		AuthInfo: DefaultCmdConfigName,
	}
	cmdCfg.CurrentContext = DefaultCmdConfigName

	return clientcmd.NewDefaultClientConfig(
		*cmdCfg,
		&clientcmd.ConfigOverrides{},
	)
}

// Extracts authorization information from the request header
func (cm *clientManager) extractAuthInfo(c *gin.Context) (*api.AuthInfo, error) {
	authHeader := c.GetHeader("Authorization")
	impersonationHeader :=c.GetHeader("Impersonate-User")
	jweToken :=c.GetHeader(JWETokenHeader)

	// Authorization header will be more important than our token
	token := cm.extractTokenFromHeader(authHeader)
	if len(token) > 0 {

		authInfo := &api.AuthInfo{Token: token}

		if len(impersonationHeader) > 0 {
			//there's an impersonation header, lets make sure to add it
			authInfo.Impersonate = impersonationHeader

			//Check for impersonated groups
			if groupsImpersonationHeader := c.Request.Header.Values("Impersonate-Group"); len(groupsImpersonationHeader) > 0 {
				authInfo.ImpersonateGroups = groupsImpersonationHeader
			}

			//check for extra fields
			for headerName, headerValues := range c.Request.Header {
				if strings.HasPrefix(headerName, ImpersonateUserExtraHeader) {
					extraName := headerName[len(ImpersonateUserExtraHeader):]
					if authInfo.ImpersonateUserExtra == nil {
						authInfo.ImpersonateUserExtra = make(map[string][]string)
					}
					authInfo.ImpersonateUserExtra[extraName] = headerValues
				}
			}
		}

		return authInfo, nil
	}

	if cm.tokenManager != nil && len(jweToken) > 0 {
		return cm.tokenManager.Decrypt(jweToken)
	}

	return nil, errors.NewUnauthorized(errors.MsgLoginUnauthorizedError)
}

// Checks if request headers contain any auth information without parsing.
func (cm *clientManager) containsAuthInfo(c *gin.Context) bool {
	authHeader :=c.GetHeader("Authorization")
	jweToken :=c.GetHeader(JWETokenHeader)

	return len(authHeader) > 0 || len(jweToken) > 0
}

func (cm *clientManager) extractTokenFromHeader(authHeader string) string {
	if strings.HasPrefix(authHeader, "Bearer ") {
		return strings.TrimPrefix(authHeader, "Bearer ")
	}

	return ""
}

func (cm *clientManager) isLoginEnabled(c *gin.Context) bool {
	return c.Request.TLS != nil || args.Holder.GetEnableInsecureLogin()
}

// Secure mode means that every request to Dashboard has to be authenticated and privileges
// of Dashboard SA can not be used.
func (cm *clientManager) isSecureModeEnabled(c *gin.Context) bool {
	if cm.isLoginEnabled(c) && !args.Holder.GetEnableSkipLogin() {
		return true
	}

	return cm.isLoginEnabled(c) && args.Holder.GetEnableSkipLogin() && cm.containsAuthInfo(c)
}

func (cm *clientManager) secureClient(c *gin.Context) (kubernetes.Interface, error) {
	cfg, err := cm.secureConfig(c)
	if err != nil {
		return nil, err
	}

	client, err := kubernetes.NewForConfig(cfg)
	if err != nil {
		return nil, err
	}

	return client, nil
}

func (cm *clientManager) secureAPIExtensionsClient(c *gin.Context) (apiextensionsclientset.Interface, error) {
	cfg, err := cm.secureConfig(c)
	if err != nil {
		return nil, err
	}

	client, err := apiextensionsclientset.NewForConfig(cfg)
	if err != nil {
		return nil, err
	}

	return client, nil
}

func (cm *clientManager) securePluginClient(c *gin.Context) (pluginclientset.Interface, error) {
	cfg, err := cm.secureConfig(c)
	if err != nil {
		return nil, err
	}

	client, err := pluginclientset.NewForConfig(cfg)
	if err != nil {
		return nil, err
	}

	return client, nil
}

func (cm *clientManager) secureConfig(c *gin.Context) (*rest.Config, error) {
	cmdConfig, err := cm.ClientCmdConfig(c)
	if err != nil {
		return nil, err
	}

	cfg, err := cmdConfig.ClientConfig()
	if err != nil {
		return nil, err
	}

	cm.initConfig(cfg)
	return cfg, nil
}

// Initializes client manager
func (cm *clientManager) init() {
	cm.initInClusterConfig()
	cm.initInsecureClients()
	cm.initCSRFKey()
}

// Initializes in-cluster config if apiserverHost and kubeConfigPath were not provided.
func (cm *clientManager) initInClusterConfig() {
	if len(cm.apiserverHost) > 0 || len(cm.kubeConfigPath) > 0 {
		log.Print("Skipping in-cluster config")
		return
	}

	log.Print("Using in-cluster config to connect to apiserver")
	cfg, err := rest.InClusterConfig()
	if err != nil {
		log.Printf("Could not init in cluster config: %s", err.Error())
		return
	}

	cm.inClusterConfig = cfg
}

// Initializes csrfKey. If in-cluster config is detected then csrf key is initialized with
// service account token, otherwise it is generated
func (cm *clientManager) initCSRFKey() {
	if cm.inClusterConfig == nil {
		// Most likely running for a dev, so no replica issues, just generate a random key
		log.Println("Using random key for csrf signing")
		cm.csrfKey = clientapi.GenerateCSRFKey()
		return
	}

	// We run in a cluster, so we should use a signing key that is the same for potential replications
	log.Println("Using secret token for csrf signing")
	cm.csrfKey = csrf.NewCsrfTokenManager(cm.insecureClient).Token()
}

// Initializes Kubernetes client and API extensions client.
func (cm *clientManager) initInsecureClients() {
	cm.initInsecureConfig()
	k8sClient, err := kubernetes.NewForConfig(cm.insecureConfig)
	if err != nil {
		panic(err)
	}

	apiextensionsclient, err := apiextensionsclientset.NewForConfig(cm.insecureConfig)
	if err != nil {
		panic(err)
	}

	pluginclient, err := pluginclientset.NewForConfig(cm.insecureConfig)
	if err != nil {
		panic(err)
	}

	cm.insecureClient = k8sClient
	cm.insecureAPIExtensionsClient = apiextensionsclient
	cm.insecurePluginClient = pluginclient
}

func (cm *clientManager) initInsecureConfig() {
	cfg, err := cm.buildConfigFromFlags(cm.apiserverHost, cm.kubeConfigPath)
	if err != nil {
		panic(err)
	}

	cm.initConfig(cfg)
	cm.insecureConfig = cfg
}

// Returns true if in-cluster config is used
func (cm *clientManager) isRunningInCluster() bool {
	return cm.inClusterConfig != nil
}

// NewClientManager creates client manager based on kubeConfigPath and apiserverHost parameters.
// If both are empty then in-cluster config is used.
func NewClientManager(kubeConfigPath, apiserverHost string) clientapi.ClientManager {
	result := &clientManager{
		kubeConfigPath: kubeConfigPath,
		apiserverHost:  apiserverHost,
	}

	result.init()
	return result
}
